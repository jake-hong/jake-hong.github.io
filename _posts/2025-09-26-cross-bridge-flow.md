---
layout: post
title: "크로스체인 브릿지 동작 원리 정리"
date: 2025-09-26
categories: blockchain
---

# 크로스체인 브릿지 동작 원리 정리

최근에 [크로스체인 브릿지 프로젝트](https://github.com/jake-hong/cross-chain-bridge)를 진행하면서 Bridge Contract와 WrappedToken Contract를 직접 구현하게 되었는데요. 

코드를 작성하면서 브릿지가 어떻게 동작하는지 전체적인 플로우를 한번 정리해보려고 합니다.

크로스체인 브릿지는 서로 다른 블록체인 간에 자산을 이동시킬 수 있게 해주는 핵심 인프라인데, 처음 접하면 조금 복잡할 수 있어서 단계별로 정리해봤습니다.

## 이더리움에서 폴리곤으로 토큰 전송하기

예를 들어 이더리움에 있는 USDT를 폴리곤으로 옮기고 싶다고 해볼게요. 어떤 과정을 거치는지 살펴보겠습니다.

### 1단계: 이더리움에서 토큰 잠그기
먼저 이더리움(소스체인)에서 일어나는 일들입니다:
1. 사용자가 `Bridge.lockTokens()` 함수를 호출합니다.
2. 원본 USDT가 Bridge 컨트랙트에 안전하게 잠기게 됩니다.
3. 이 과정에서 `TokensLocked` 이벤트가 발생합니다.

### 2단계: 릴레이어가 중간 다리 역할
오프체인에서 릴레이어가 활동을 시작합니다:
1. 이더리움에서 발생한 `TokensLocked` 이벤트를 감지합니다.
2. 여러 검증자들이 이 트랜잭션을 확인하고 서명을 생성합니다.

### 3단계: 폴리곤에서 새로운 토큰 발행
이제 폴리곤(목적지체인)에서:
1. Bridge가 `WrappedToken.mint()` 함수를 실행합니다.
2. 이더리움에 잠긴 USDT와 동일한 수량의 Wrapped USDT가 생성됩니다.
3. 드디어 사용자는 폴리곤에서 Wrapped USDT를 사용할 수 있게 됩니다.

## 다시 이더리움으로 돌아오기

이번엔 반대로 폴리곤에서 이더리움으로 토큰을 되돌려보내는 과정을 살펴볼까요?

### 1단계: 폴리곤에서 토큰 소각
폴리곤(이번엔 소스체인)에서:
1. 사용자가 `WrappedToken.burn()` 함수를 호출합니다.
2. Wrapped USDT가 영구적으로 소각됩니다.
3. `TokensBurned` 이벤트가 발생합니다.

### 2단계: 릴레이어가 다시 연결
똑같이 오프체인 릴레이어가:
1. 폴리곤의 `TokensBurned` 이벤트를 감지하고,
2. 검증자들이 확인 후 서명을 생성합니다.

### 3단계: 이더리움에서 토큰 잠금 해제
마지막으로 이더리움(목적지체인)에서:
1. `Bridge.unlockTokens()` 함수가 실행됩니다.
2. 처음에 잠겨있던 원본 USDT가 해제됩니다.
3. 사용자는 다시 원래의 USDT를 돌려받게 됩니다.

## 알아두면 좋은 핵심 포인트들

### WrappedToken은 어디에 배포되나요?
이게 처음엔 좀 헷갈렸는데요:
- 이더리움 → 폴리곤으로 가면: WrappedToken은 **폴리곤**에 배포됩니다.
- 폴리곤 → 이더리움으로 가면: WrappedToken은 **이더리움**에 배포돼요.

쉽게 말해, WrappedToken은 항상 목적지 체인에 존재한다고 보면 됩니다!

### 1:1 페깅이 어떻게 유지되나요?
이건 정말 중요한 부분인데요:
- 소스체인에서 100 USDT를 잠그면,
- 목적지체인에서 정확히 100 Wrapped USDT가 발행됩니다.
- 이렇게 해서 전체 공급량은 항상 일정하게 유지돼요.

인플레이션이나 디플레이션 없이 안전하게 자산을 이동시킬 수 있는 거죠.

### 릴레이어는 뭘 하는 거예요?
릴레이어는 정말 중요한 역할을 합니다.
- 한 체인에서 발생한 이벤트를 감지하고,
- 다른 체인으로 이 정보를 안전하게 전달합니다.
- 여러 검증자의 서명을 통해 보안을 유지합니다.

말하자면 두 블록체인 사이의 신뢰할 수 있는 메신저 역할을 하는 거예요.

---

이렇게 정리하고 보니 크로스체인 브릿지의 동작 원리가 좀 더 명확해진 것 같습니다. 